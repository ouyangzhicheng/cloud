package com.cloud.sbjm.security;import java.io.IOException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import com.cloud.sbjm.common.Constant;import com.cloud.sbjm.common.SpringContextHolder;import com.cloud.sbjm.domain.UserInfo;import com.cloud.sbjm.repository.UserRepository;import com.fasterxml.jackson.databind.ObjectMapper;/** * @author ouyang */public class LoginStatusInterceptor implements HandlerInterceptor {    private Logger logger = LoggerFactory.getLogger(LoginStatusInterceptor.class);    public static RedisTemplate<String, Object> redisTemplate;    public LoginStatusInterceptor(RedisTemplate<String, Object> redisTemplate) {        this.redisTemplate = redisTemplate;    }    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println("111111");        //1获取本次访问的头文件信息        String requestHeaderUserToken = request.getHeader("userToken");        String requestHeaderAccountId = request.getHeader("accountId");        String requestHeaderUserSeq = request.getHeader("userSeq");        System.out.println(requestHeaderUserToken);        System.out.println(requestHeaderAccountId);        System.out.println(requestHeaderUserSeq);        //2.校验头文件的token值        if (StringUtils.isBlank(requestHeaderUserToken)) {            sendResponseJson(Constant.USER_TOKEN_IS_NULL_CODE, Constant.USER_TOKEN_IS_NULL_MSG, response);            return false;        }        //3.校验头文件的用户名        if (StringUtils.isBlank(requestHeaderAccountId)) {            sendResponseJson(Constant.USER_NAME_IS_NULL_CODE, Constant.USER_NAME_IS_NULL_MSG, response);            return false;        }        //4.验证头文件的时间戳        if (StringUtils.isBlank(requestHeaderUserSeq)) {            sendResponseJson(Constant.USER_SEQ_IS_NULL_CODE, Constant.USER_SEQ_IS_NULL_MSG, response);            return false;        }        //5.根据本次访问的头文件信息来从缓存里获取对应的Token值，若无，再去数据库找，再进行校验        //5.1先判断是否有开启缓存,没有开启的话，就直接去数据库里查询token        if (null != redisTemplate) {            String tokenKey = requestHeaderAccountId + "Token";            String userLoginTokenJson = (String) redisTemplate.opsForValue().get(tokenKey);            System.out.println(userLoginTokenJson);            //5.2.判断本次访问的用户在缓存里是否有对应token            if (StringUtils.isBlank(userLoginTokenJson)) {                //5.3缓存里为空，去数据库里查找token值进行校验                UserRepository userRepository = SpringContextHolder.getBean("userRepositoryImpl", UserRepository.class);//看了大牛写的主动获取spring的bean                UserInfo user = userRepository.getUserInfoByAccountId(requestHeaderAccountId);                if (user != null) {                    if (user.getUserToken().equals(requestHeaderUserToken)) {                        //校验通过                        return true;                    } else {                        //校验不通过                        sendResponseJson(Constant.USER_TOKEN_ERROR_CODE, Constant.USER_TOKEN_ERROR_MSG, response);                        return false;                    }                } else {                    //校验不通过                    sendResponseJson(Constant.USER_TOKEN_ERROR_CODE, Constant.USER_TOKEN_ERROR_MSG, response);                    return false;                }            } else {                //5.4缓存里不为空，则拿出token值进行校验                UserLoginToken userLoginToken = new ObjectMapper().readValue(userLoginTokenJson, UserLoginToken.class);                System.out.println("************************************token对比");                System.out.println(requestHeaderUserToken);                System.out.println(userLoginToken.getUserToken());                if (userLoginToken.getUserToken().equals(requestHeaderUserToken)) {                    //校验通过                    return true;                } else {                    //校验不通过                    sendResponseJson(Constant.USER_TOKEN_ERROR_CODE, Constant.USER_TOKEN_ERROR_MSG, response);                    return false;                }            }        } else {            //缓存没开启，直接到数据库里查询            UserRepository userRepository = SpringContextHolder.getBean("userRepositoryImpl", UserRepository.class);//看了大牛写的主动获取spring的bean            UserInfo user = userRepository.getUserInfoByAccountId(requestHeaderAccountId);            if (user.getUserToken().equals(requestHeaderUserToken)) {                //校验通过                return true;            } else {                //校验不通过                sendResponseJson(Constant.USER_TOKEN_ERROR_CODE, Constant.USER_TOKEN_ERROR_MSG, response);                return false;            }        }    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println("222222");    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println("333333333");    }    private void sendResponseJson(String tokenErrorCode, String tokenErrorMsg, HttpServletResponse response) {        try {            String responseStr = "{\"code\":" + tokenErrorCode + ",\"msg\":\"" + tokenErrorMsg + "\",\"seq\":\"" + System.currentTimeMillis() / 1000 + "\"}";            logger.info("sendResponseJson:" + responseStr);            response.setHeader("Content-Type", "application/json");            response.getWriter().write(responseStr);            response.getWriter().flush();        } catch (IOException e) {            logger.error("发送响应报文时发生错误:" + e.getMessage());        }    }}