package com.cloud.sbjm.service.Imp;import javax.jms.Destination;import javax.jms.Queue;import javax.jms.Topic;import org.apache.activemq.command.ActiveMQQueue;import org.apache.activemq.command.ActiveMQTopic;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.annotation.JmsListener;import org.springframework.jms.core.JmsMessagingTemplate;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Service;import com.cloud.sbjm.service.JmsProducerService;/** * 消息生产者 */@Servicepublic class JmsProducerServiceImpl implements JmsProducerService {    @Autowired // 也可以注入JmsTemplate，JmsMessagingTemplate对JmsTemplate进行了封装    private JmsMessagingTemplate jmsTemplate;    /**     * 1生产者发送消息(发送信息到队列)     * 根据实例化Destination目的地参数的类型的对象决定是点对点队列的形式，还是广播的形式     */    //@Scheduled(fixedRate = 5000)    @Override    public void queueSend() {        //定义一个目的地（队列类型）        Destination queue = new ActiveMQQueue("mytest.queue");        jmsTemplate.convertAndSend(queue, "myname is Oyzc");    }    /**     * 2生产者发送消息(发送信息到话题)     */    //@Scheduled(fixedRate = 5000)    @Override    public void topicSend() {        //定义一个目的地（队列类型）        Destination topic = new ActiveMQTopic("mytest.topic");        jmsTemplate.convertAndSend(topic, "myname is Oyzc");    }    /**     * 3生产者发送出去消息之后，可以马上监听指定消费者的反馈信息     *     * @param text     */    @Override    //@JmsListener(destination="out.queue")    public void consumerMessage(String text) {        System.out.println("从out.queue队列收到的回复报文为:" + text);    }}